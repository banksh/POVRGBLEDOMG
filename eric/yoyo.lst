
yoyo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  00000898  0000092c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000898  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000004  0080010e  0080010e  0000093a  2**0
                  ALLOC
  3 .stab         00001d34  00000000  00000000  0000093c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000aee  00000000  00000000  00002670  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	13 c0       	rjmp	.+38     	; 0x28 <__ctors_end>
   2:	2d c0       	rjmp	.+90     	; 0x5e <__bad_interrupt>
   4:	2c c0       	rjmp	.+88     	; 0x5e <__bad_interrupt>
   6:	2b c0       	rjmp	.+86     	; 0x5e <__bad_interrupt>
   8:	2a c0       	rjmp	.+84     	; 0x5e <__bad_interrupt>
   a:	29 c0       	rjmp	.+82     	; 0x5e <__bad_interrupt>
   c:	28 c0       	rjmp	.+80     	; 0x5e <__bad_interrupt>
   e:	27 c0       	rjmp	.+78     	; 0x5e <__bad_interrupt>
  10:	26 c0       	rjmp	.+76     	; 0x5e <__bad_interrupt>
  12:	25 c0       	rjmp	.+74     	; 0x5e <__bad_interrupt>
  14:	24 c0       	rjmp	.+72     	; 0x5e <__bad_interrupt>
  16:	23 c0       	rjmp	.+70     	; 0x5e <__bad_interrupt>
  18:	22 c0       	rjmp	.+68     	; 0x5e <__bad_interrupt>
  1a:	21 c0       	rjmp	.+66     	; 0x5e <__bad_interrupt>
  1c:	20 c0       	rjmp	.+64     	; 0x5e <__bad_interrupt>
  1e:	1f c0       	rjmp	.+62     	; 0x5e <__bad_interrupt>
  20:	1e c0       	rjmp	.+60     	; 0x5e <__bad_interrupt>
  22:	1d c0       	rjmp	.+58     	; 0x5e <__bad_interrupt>
  24:	1c c0       	rjmp	.+56     	; 0x5e <__bad_interrupt>
  26:	1b c0       	rjmp	.+54     	; 0x5e <__bad_interrupt>

00000028 <__ctors_end>:
  28:	11 24       	eor	r1, r1
  2a:	1f be       	out	0x3f, r1	; 63
  2c:	cf ef       	ldi	r28, 0xFF	; 255
  2e:	d1 e0       	ldi	r29, 0x01	; 1
  30:	de bf       	out	0x3e, r29	; 62
  32:	cd bf       	out	0x3d, r28	; 61

00000034 <__do_copy_data>:
  34:	11 e0       	ldi	r17, 0x01	; 1
  36:	a0 e0       	ldi	r26, 0x00	; 0
  38:	b1 e0       	ldi	r27, 0x01	; 1
  3a:	e8 e9       	ldi	r30, 0x98	; 152
  3c:	f8 e0       	ldi	r31, 0x08	; 8
  3e:	02 c0       	rjmp	.+4      	; 0x44 <__SREG__+0x5>
  40:	05 90       	lpm	r0, Z+
  42:	0d 92       	st	X+, r0
  44:	ae 30       	cpi	r26, 0x0E	; 14
  46:	b1 07       	cpc	r27, r17
  48:	d9 f7       	brne	.-10     	; 0x40 <__SREG__+0x1>

0000004a <__do_clear_bss>:
  4a:	11 e0       	ldi	r17, 0x01	; 1
  4c:	ae e0       	ldi	r26, 0x0E	; 14
  4e:	b1 e0       	ldi	r27, 0x01	; 1
  50:	01 c0       	rjmp	.+2      	; 0x54 <.do_clear_bss_start>

00000052 <.do_clear_bss_loop>:
  52:	1d 92       	st	X+, r1

00000054 <.do_clear_bss_start>:
  54:	a2 31       	cpi	r26, 0x12	; 18
  56:	b1 07       	cpc	r27, r17
  58:	e1 f7       	brne	.-8      	; 0x52 <.do_clear_bss_loop>
  5a:	96 d3       	rcall	.+1836   	; 0x788 <main>
  5c:	1b c4       	rjmp	.+2102   	; 0x894 <_exit>

0000005e <__bad_interrupt>:
  5e:	d0 cf       	rjmp	.-96     	; 0x0 <__vectors>

00000060 <accel_init>:
#define FF_MT_SRC	0x16
#define FF_MT_THS	0x17
#define FF_MT_COUNT	0x18

void accel_init()
{
  60:	df 93       	push	r29
  62:	cf 93       	push	r28
  64:	0f 92       	push	r0
  66:	cd b7       	in	r28, 0x3d	; 61
  68:	de b7       	in	r29, 0x3e	; 62
	uint8_t result;
	accel_write_single(ACCEL_1,CTRL_REG2,0x40); // RESET
  6a:	8a e3       	ldi	r24, 0x3A	; 58
  6c:	90 e0       	ldi	r25, 0x00	; 0
  6e:	6b e2       	ldi	r22, 0x2B	; 43
  70:	70 e0       	ldi	r23, 0x00	; 0
  72:	40 e4       	ldi	r20, 0x40	; 64
  74:	50 e0       	ldi	r21, 0x00	; 0
  76:	0a d3       	rcall	.+1556   	; 0x68c <accel_write_single>
	accel_write_single(ACCEL_2,CTRL_REG2,0x40); // RESET
  78:	88 e3       	ldi	r24, 0x38	; 56
  7a:	90 e0       	ldi	r25, 0x00	; 0
  7c:	6b e2       	ldi	r22, 0x2B	; 43
  7e:	70 e0       	ldi	r23, 0x00	; 0
  80:	40 e4       	ldi	r20, 0x40	; 64
  82:	50 e0       	ldi	r21, 0x00	; 0
  84:	03 d3       	rcall	.+1542   	; 0x68c <accel_write_single>
  86:	01 c0       	rjmp	.+2      	; 0x8a <accel_init+0x2a>
		accel_read_single(ACCEL_1,CTRL_REG2,&result);
		if(!(result & 0x40))
		{
			break;
		}
	}
  88:	00 00       	nop
	uint8_t result;
	accel_write_single(ACCEL_1,CTRL_REG2,0x40); // RESET
	accel_write_single(ACCEL_2,CTRL_REG2,0x40); // RESET
	for(;;)
	{
		accel_read_single(ACCEL_1,CTRL_REG2,&result);
  8a:	8a e3       	ldi	r24, 0x3A	; 58
  8c:	6b e2       	ldi	r22, 0x2B	; 43
  8e:	9e 01       	movw	r18, r28
  90:	2f 5f       	subi	r18, 0xFF	; 255
  92:	3f 4f       	sbci	r19, 0xFF	; 255
  94:	a9 01       	movw	r20, r18
  96:	bc d2       	rcall	.+1400   	; 0x610 <accel_read_single>
		if(!(result & 0x40))
  98:	89 81       	ldd	r24, Y+1	; 0x01
  9a:	88 2f       	mov	r24, r24
  9c:	90 e0       	ldi	r25, 0x00	; 0
  9e:	80 74       	andi	r24, 0x40	; 64
  a0:	90 70       	andi	r25, 0x00	; 0
  a2:	00 97       	sbiw	r24, 0x00	; 0
  a4:	89 f7       	brne	.-30     	; 0x88 <accel_init+0x28>
		{
			break;
  a6:	00 00       	nop
  a8:	01 c0       	rjmp	.+2      	; 0xac <accel_init+0x4c>
		accel_read_single(ACCEL_2,CTRL_REG2,&result);
		if(!(result & 0x40))
		{
			break;
		}
	}
  aa:	00 00       	nop
			break;
		}
	}
	for(;;)
	{
		accel_read_single(ACCEL_2,CTRL_REG2,&result);
  ac:	88 e3       	ldi	r24, 0x38	; 56
  ae:	6b e2       	ldi	r22, 0x2B	; 43
  b0:	9e 01       	movw	r18, r28
  b2:	2f 5f       	subi	r18, 0xFF	; 255
  b4:	3f 4f       	sbci	r19, 0xFF	; 255
  b6:	a9 01       	movw	r20, r18
  b8:	ab d2       	rcall	.+1366   	; 0x610 <accel_read_single>
		if(!(result & 0x40))
  ba:	89 81       	ldd	r24, Y+1	; 0x01
  bc:	88 2f       	mov	r24, r24
  be:	90 e0       	ldi	r25, 0x00	; 0
  c0:	80 74       	andi	r24, 0x40	; 64
  c2:	90 70       	andi	r25, 0x00	; 0
  c4:	00 97       	sbiw	r24, 0x00	; 0
  c6:	89 f7       	brne	.-30     	; 0xaa <accel_init+0x4a>
		{
			break;
		}
	}

	accel_write_single(ACCEL_1,FF_MT_CFG,0xF8); // Motion detect
  c8:	8a e3       	ldi	r24, 0x3A	; 58
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	65 e1       	ldi	r22, 0x15	; 21
  ce:	70 e0       	ldi	r23, 0x00	; 0
  d0:	48 ef       	ldi	r20, 0xF8	; 248
  d2:	50 e0       	ldi	r21, 0x00	; 0
  d4:	db d2       	rcall	.+1462   	; 0x68c <accel_write_single>
	accel_write_single(ACCEL_1,FF_MT_THS,0xC0); // Motion threshold at 2g
  d6:	8a e3       	ldi	r24, 0x3A	; 58
  d8:	90 e0       	ldi	r25, 0x00	; 0
  da:	67 e1       	ldi	r22, 0x17	; 23
  dc:	70 e0       	ldi	r23, 0x00	; 0
  de:	40 ec       	ldi	r20, 0xC0	; 192
  e0:	50 e0       	ldi	r21, 0x00	; 0
  e2:	d4 d2       	rcall	.+1448   	; 0x68c <accel_write_single>
	accel_write_single(ACCEL_1,FF_MT_COUNT,0x01); // Debounce time at 80ms
  e4:	8a e3       	ldi	r24, 0x3A	; 58
  e6:	90 e0       	ldi	r25, 0x00	; 0
  e8:	68 e1       	ldi	r22, 0x18	; 24
  ea:	70 e0       	ldi	r23, 0x00	; 0
  ec:	41 e0       	ldi	r20, 0x01	; 1
  ee:	50 e0       	ldi	r21, 0x00	; 0
  f0:	cd d2       	rcall	.+1434   	; 0x68c <accel_write_single>

	accel_write_single(ACCEL_1,CTRL_REG2,0x18); // Low power sleep mode
  f2:	8a e3       	ldi	r24, 0x3A	; 58
  f4:	90 e0       	ldi	r25, 0x00	; 0
  f6:	6b e2       	ldi	r22, 0x2B	; 43
  f8:	70 e0       	ldi	r23, 0x00	; 0
  fa:	48 e1       	ldi	r20, 0x18	; 24
  fc:	50 e0       	ldi	r21, 0x00	; 0
  fe:	c6 d2       	rcall	.+1420   	; 0x68c <accel_write_single>
	accel_write_single(ACCEL_1,CTRL_REG3,0x08); // Wake up interrupt on motion
 100:	8a e3       	ldi	r24, 0x3A	; 58
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	6c e2       	ldi	r22, 0x2C	; 44
 106:	70 e0       	ldi	r23, 0x00	; 0
 108:	48 e0       	ldi	r20, 0x08	; 8
 10a:	50 e0       	ldi	r21, 0x00	; 0
 10c:	bf d2       	rcall	.+1406   	; 0x68c <accel_write_single>
	accel_write_single(ACCEL_1,CTRL_REG4,0x04); // Motion interrupt enable
 10e:	8a e3       	ldi	r24, 0x3A	; 58
 110:	90 e0       	ldi	r25, 0x00	; 0
 112:	6d e2       	ldi	r22, 0x2D	; 45
 114:	70 e0       	ldi	r23, 0x00	; 0
 116:	44 e0       	ldi	r20, 0x04	; 4
 118:	50 e0       	ldi	r21, 0x00	; 0
 11a:	b8 d2       	rcall	.+1392   	; 0x68c <accel_write_single>
	accel_write_single(ACCEL_1,CTRL_REG5,0x04); // Motion interrupt to INT1	
 11c:	8a e3       	ldi	r24, 0x3A	; 58
 11e:	90 e0       	ldi	r25, 0x00	; 0
 120:	6e e2       	ldi	r22, 0x2E	; 46
 122:	70 e0       	ldi	r23, 0x00	; 0
 124:	44 e0       	ldi	r20, 0x04	; 4
 126:	50 e0       	ldi	r21, 0x00	; 0
 128:	b1 d2       	rcall	.+1378   	; 0x68c <accel_write_single>

	accel_write_single(ACCEL_1,XYZ_DATA_CFG,0x02); // 8g
 12a:	8a e3       	ldi	r24, 0x3A	; 58
 12c:	90 e0       	ldi	r25, 0x00	; 0
 12e:	6e e0       	ldi	r22, 0x0E	; 14
 130:	70 e0       	ldi	r23, 0x00	; 0
 132:	42 e0       	ldi	r20, 0x02	; 2
 134:	50 e0       	ldi	r21, 0x00	; 0
 136:	aa d2       	rcall	.+1364   	; 0x68c <accel_write_single>
}
 138:	0f 90       	pop	r0
 13a:	cf 91       	pop	r28
 13c:	df 91       	pop	r29
 13e:	08 95       	ret

00000140 <accel_run>:

// Turns on accelerometers
void accel_run()
{
 140:	df 93       	push	r29
 142:	cf 93       	push	r28
 144:	cd b7       	in	r28, 0x3d	; 61
 146:	de b7       	in	r29, 0x3e	; 62
	accel_write_single(ACCEL_1,CTRL_REG1,0x00); // Enter standby
 148:	8a e3       	ldi	r24, 0x3A	; 58
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	6a e2       	ldi	r22, 0x2A	; 42
 14e:	70 e0       	ldi	r23, 0x00	; 0
 150:	40 e0       	ldi	r20, 0x00	; 0
 152:	50 e0       	ldi	r21, 0x00	; 0
 154:	9b d2       	rcall	.+1334   	; 0x68c <accel_write_single>
	accel_write_single(ACCEL_2,CTRL_REG1,0x00);
 156:	88 e3       	ldi	r24, 0x38	; 56
 158:	90 e0       	ldi	r25, 0x00	; 0
 15a:	6a e2       	ldi	r22, 0x2A	; 42
 15c:	70 e0       	ldi	r23, 0x00	; 0
 15e:	40 e0       	ldi	r20, 0x00	; 0
 160:	50 e0       	ldi	r21, 0x00	; 0
 162:	94 d2       	rcall	.+1320   	; 0x68c <accel_write_single>

	accel_write_single(ACCEL_2,XYZ_DATA_CFG,0x02); // 8g
 164:	88 e3       	ldi	r24, 0x38	; 56
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	6e e0       	ldi	r22, 0x0E	; 14
 16a:	70 e0       	ldi	r23, 0x00	; 0
 16c:	42 e0       	ldi	r20, 0x02	; 2
 16e:	50 e0       	ldi	r21, 0x00	; 0
 170:	8d d2       	rcall	.+1306   	; 0x68c <accel_write_single>

	accel_write_single(ACCEL_1,CTRL_REG1,0x01); // Enter active, data rate = 800 Hz
 172:	8a e3       	ldi	r24, 0x3A	; 58
 174:	90 e0       	ldi	r25, 0x00	; 0
 176:	6a e2       	ldi	r22, 0x2A	; 42
 178:	70 e0       	ldi	r23, 0x00	; 0
 17a:	41 e0       	ldi	r20, 0x01	; 1
 17c:	50 e0       	ldi	r21, 0x00	; 0
 17e:	86 d2       	rcall	.+1292   	; 0x68c <accel_write_single>
	accel_write_single(ACCEL_2,CTRL_REG1,0x01);
 180:	88 e3       	ldi	r24, 0x38	; 56
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	6a e2       	ldi	r22, 0x2A	; 42
 186:	70 e0       	ldi	r23, 0x00	; 0
 188:	41 e0       	ldi	r20, 0x01	; 1
 18a:	50 e0       	ldi	r21, 0x00	; 0
 18c:	7f d2       	rcall	.+1278   	; 0x68c <accel_write_single>
}
 18e:	cf 91       	pop	r28
 190:	df 91       	pop	r29
 192:	08 95       	ret

00000194 <accel_sleep>:

void accel_sleep()
{
 194:	df 93       	push	r29
 196:	cf 93       	push	r28
 198:	0f 92       	push	r0
 19a:	cd b7       	in	r28, 0x3d	; 61
 19c:	de b7       	in	r29, 0x3e	; 62
	uint8_t result;
	accel_write_single(ACCEL_1,CTRL_REG1,0x00); // Enter standby
 19e:	8a e3       	ldi	r24, 0x3A	; 58
 1a0:	90 e0       	ldi	r25, 0x00	; 0
 1a2:	6a e2       	ldi	r22, 0x2A	; 42
 1a4:	70 e0       	ldi	r23, 0x00	; 0
 1a6:	40 e0       	ldi	r20, 0x00	; 0
 1a8:	50 e0       	ldi	r21, 0x00	; 0
 1aa:	70 d2       	rcall	.+1248   	; 0x68c <accel_write_single>
//	accel_write_single(ACCEL_2,CTRL_REG1,0x00); // Enter standby
	accel_read_single(ACCEL_1,FF_MT_SRC,&result); // Clear pending interrupt
 1ac:	8a e3       	ldi	r24, 0x3A	; 58
 1ae:	66 e1       	ldi	r22, 0x16	; 22
 1b0:	9e 01       	movw	r18, r28
 1b2:	2f 5f       	subi	r18, 0xFF	; 255
 1b4:	3f 4f       	sbci	r19, 0xFF	; 255
 1b6:	a9 01       	movw	r20, r18
 1b8:	2b d2       	rcall	.+1110   	; 0x610 <accel_read_single>
	accel_write_single(ACCEL_1,CTRL_REG1,0x29); // Enter active, data rate = 12.5 Hz
 1ba:	8a e3       	ldi	r24, 0x3A	; 58
 1bc:	90 e0       	ldi	r25, 0x00	; 0
 1be:	6a e2       	ldi	r22, 0x2A	; 42
 1c0:	70 e0       	ldi	r23, 0x00	; 0
 1c2:	49 e2       	ldi	r20, 0x29	; 41
 1c4:	50 e0       	ldi	r21, 0x00	; 0
 1c6:	62 d2       	rcall	.+1220   	; 0x68c <accel_write_single>
}
 1c8:	0f 90       	pop	r0
 1ca:	cf 91       	pop	r28
 1cc:	df 91       	pop	r29
 1ce:	08 95       	ret

000001d0 <get_centrifugal_acceleration>:

// Returns a 13-bit signed integer representing the centrifugal acceleration
int16_t get_centrifugal_acceleration()
{
 1d0:	df 93       	push	r29
 1d2:	cf 93       	push	r28
 1d4:	00 d0       	rcall	.+0      	; 0x1d6 <get_centrifugal_acceleration+0x6>
 1d6:	00 d0       	rcall	.+0      	; 0x1d8 <get_centrifugal_acceleration+0x8>
 1d8:	cd b7       	in	r28, 0x3d	; 61
 1da:	de b7       	in	r29, 0x3e	; 62
	int16_t a,b;
	accel_read_double(ACCEL_1,0x03,(uint8_t*)(&a));
 1dc:	9e 01       	movw	r18, r28
 1de:	2f 5f       	subi	r18, 0xFF	; 255
 1e0:	3f 4f       	sbci	r19, 0xFF	; 255
 1e2:	8a e3       	ldi	r24, 0x3A	; 58
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	63 e0       	ldi	r22, 0x03	; 3
 1e8:	70 e0       	ldi	r23, 0x00	; 0
 1ea:	a9 01       	movw	r20, r18
 1ec:	2e d2       	rcall	.+1116   	; 0x64a <accel_read_double>
	accel_read_double(ACCEL_2,0x03,(uint8_t*)(&b));
 1ee:	9e 01       	movw	r18, r28
 1f0:	2d 5f       	subi	r18, 0xFD	; 253
 1f2:	3f 4f       	sbci	r19, 0xFF	; 255
 1f4:	88 e3       	ldi	r24, 0x38	; 56
 1f6:	90 e0       	ldi	r25, 0x00	; 0
 1f8:	63 e0       	ldi	r22, 0x03	; 3
 1fa:	70 e0       	ldi	r23, 0x00	; 0
 1fc:	a9 01       	movw	r20, r18
 1fe:	25 d2       	rcall	.+1098   	; 0x64a <accel_read_double>
	return (a>>5)+(b>>5);
 200:	89 81       	ldd	r24, Y+1	; 0x01
 202:	9a 81       	ldd	r25, Y+2	; 0x02
 204:	9c 01       	movw	r18, r24
 206:	35 95       	asr	r19
 208:	27 95       	ror	r18
 20a:	35 95       	asr	r19
 20c:	27 95       	ror	r18
 20e:	35 95       	asr	r19
 210:	27 95       	ror	r18
 212:	35 95       	asr	r19
 214:	27 95       	ror	r18
 216:	35 95       	asr	r19
 218:	27 95       	ror	r18
 21a:	8b 81       	ldd	r24, Y+3	; 0x03
 21c:	9c 81       	ldd	r25, Y+4	; 0x04
 21e:	95 95       	asr	r25
 220:	87 95       	ror	r24
 222:	95 95       	asr	r25
 224:	87 95       	ror	r24
 226:	95 95       	asr	r25
 228:	87 95       	ror	r24
 22a:	95 95       	asr	r25
 22c:	87 95       	ror	r24
 22e:	95 95       	asr	r25
 230:	87 95       	ror	r24
 232:	82 0f       	add	r24, r18
 234:	93 1f       	adc	r25, r19
}
 236:	0f 90       	pop	r0
 238:	0f 90       	pop	r0
 23a:	0f 90       	pop	r0
 23c:	0f 90       	pop	r0
 23e:	cf 91       	pop	r28
 240:	df 91       	pop	r29
 242:	08 95       	ret

00000244 <init>:

uint8_t black[4]={0,0,0,0};

// Configure chip
void init()
{
 244:	df 93       	push	r29
 246:	cf 93       	push	r28
 248:	cd b7       	in	r28, 0x3d	; 61
 24a:	de b7       	in	r29, 0x3e	; 62
	DDRB |= (1<<DDB3) | (1<<DDB5) | (1<<DDB2); // MOSI, SCK, and 3V_EN
 24c:	84 e2       	ldi	r24, 0x24	; 36
 24e:	90 e0       	ldi	r25, 0x00	; 0
 250:	24 e2       	ldi	r18, 0x24	; 36
 252:	30 e0       	ldi	r19, 0x00	; 0
 254:	f9 01       	movw	r30, r18
 256:	20 81       	ld	r18, Z
 258:	2c 62       	ori	r18, 0x2C	; 44
 25a:	fc 01       	movw	r30, r24
 25c:	20 83       	st	Z, r18
	DDRD |= (1<<DDD6) | (1<<DDD7); // LED Enable and Latch
 25e:	8a e2       	ldi	r24, 0x2A	; 42
 260:	90 e0       	ldi	r25, 0x00	; 0
 262:	2a e2       	ldi	r18, 0x2A	; 42
 264:	30 e0       	ldi	r19, 0x00	; 0
 266:	f9 01       	movw	r30, r18
 268:	20 81       	ld	r18, Z
 26a:	20 6c       	ori	r18, 0xC0	; 192
 26c:	fc 01       	movw	r30, r24
 26e:	20 83       	st	Z, r18
	DDRC |= (1<<DDC0); // Flash CS
 270:	87 e2       	ldi	r24, 0x27	; 39
 272:	90 e0       	ldi	r25, 0x00	; 0
 274:	27 e2       	ldi	r18, 0x27	; 39
 276:	30 e0       	ldi	r19, 0x00	; 0
 278:	f9 01       	movw	r30, r18
 27a:	20 81       	ld	r18, Z
 27c:	21 60       	ori	r18, 0x01	; 1
 27e:	fc 01       	movw	r30, r24
 280:	20 83       	st	Z, r18

	PORTC |= (1<<PC0); // Deselect flash
 282:	88 e2       	ldi	r24, 0x28	; 40
 284:	90 e0       	ldi	r25, 0x00	; 0
 286:	28 e2       	ldi	r18, 0x28	; 40
 288:	30 e0       	ldi	r19, 0x00	; 0
 28a:	f9 01       	movw	r30, r18
 28c:	20 81       	ld	r18, Z
 28e:	21 60       	ori	r18, 0x01	; 1
 290:	fc 01       	movw	r30, r24
 292:	20 83       	st	Z, r18

	SPCR |= (1<<SPE) | (1<<MSTR); // SPI Configuration
 294:	8c e4       	ldi	r24, 0x4C	; 76
 296:	90 e0       	ldi	r25, 0x00	; 0
 298:	2c e4       	ldi	r18, 0x4C	; 76
 29a:	30 e0       	ldi	r19, 0x00	; 0
 29c:	f9 01       	movw	r30, r18
 29e:	20 81       	ld	r18, Z
 2a0:	20 65       	ori	r18, 0x50	; 80
 2a2:	fc 01       	movw	r30, r24
 2a4:	20 83       	st	Z, r18
	SPSR |= (1<<SPI2X);
 2a6:	8d e4       	ldi	r24, 0x4D	; 77
 2a8:	90 e0       	ldi	r25, 0x00	; 0
 2aa:	2d e4       	ldi	r18, 0x4D	; 77
 2ac:	30 e0       	ldi	r19, 0x00	; 0
 2ae:	f9 01       	movw	r30, r18
 2b0:	20 81       	ld	r18, Z
 2b2:	21 60       	ori	r18, 0x01	; 1
 2b4:	fc 01       	movw	r30, r24
 2b6:	20 83       	st	Z, r18

	PORTD |= (1<<PORTD7); // Latch
 2b8:	8b e2       	ldi	r24, 0x2B	; 43
 2ba:	90 e0       	ldi	r25, 0x00	; 0
 2bc:	2b e2       	ldi	r18, 0x2B	; 43
 2be:	30 e0       	ldi	r19, 0x00	; 0
 2c0:	f9 01       	movw	r30, r18
 2c2:	20 81       	ld	r18, Z
 2c4:	20 68       	ori	r18, 0x80	; 128
 2c6:	fc 01       	movw	r30, r24
 2c8:	20 83       	st	Z, r18

	PORTB &= ~(1<<PB2); // Turn power on to everything
 2ca:	85 e2       	ldi	r24, 0x25	; 37
 2cc:	90 e0       	ldi	r25, 0x00	; 0
 2ce:	25 e2       	ldi	r18, 0x25	; 37
 2d0:	30 e0       	ldi	r19, 0x00	; 0
 2d2:	f9 01       	movw	r30, r18
 2d4:	20 81       	ld	r18, Z
 2d6:	2b 7f       	andi	r18, 0xFB	; 251
 2d8:	fc 01       	movw	r30, r24
 2da:	20 83       	st	Z, r18

	write_leds(black);
 2dc:	8e e0       	ldi	r24, 0x0E	; 14
 2de:	91 e0       	ldi	r25, 0x01	; 1
 2e0:	03 d0       	rcall	.+6      	; 0x2e8 <write_leds>
}
 2e2:	cf 91       	pop	r28
 2e4:	df 91       	pop	r29
 2e6:	08 95       	ret

000002e8 <write_leds>:

// Turn on the LEDs according to a 4-byte frame
void write_leds(uint8_t* data)
{
 2e8:	df 93       	push	r29
 2ea:	cf 93       	push	r28
 2ec:	00 d0       	rcall	.+0      	; 0x2ee <write_leds+0x6>
 2ee:	cd b7       	in	r28, 0x3d	; 61
 2f0:	de b7       	in	r29, 0x3e	; 62
 2f2:	9a 83       	std	Y+2, r25	; 0x02
 2f4:	89 83       	std	Y+1, r24	; 0x01
	SPDR = data[0];
 2f6:	8e e4       	ldi	r24, 0x4E	; 78
 2f8:	90 e0       	ldi	r25, 0x00	; 0
 2fa:	29 81       	ldd	r18, Y+1	; 0x01
 2fc:	3a 81       	ldd	r19, Y+2	; 0x02
 2fe:	f9 01       	movw	r30, r18
 300:	20 81       	ld	r18, Z
 302:	fc 01       	movw	r30, r24
 304:	20 83       	st	Z, r18
	while(!(SPSR & (1<<SPIF)));
 306:	00 00       	nop
 308:	8d e4       	ldi	r24, 0x4D	; 77
 30a:	90 e0       	ldi	r25, 0x00	; 0
 30c:	fc 01       	movw	r30, r24
 30e:	80 81       	ld	r24, Z
 310:	88 23       	and	r24, r24
 312:	d4 f7       	brge	.-12     	; 0x308 <write_leds+0x20>
	SPDR = data[1];
 314:	8e e4       	ldi	r24, 0x4E	; 78
 316:	90 e0       	ldi	r25, 0x00	; 0
 318:	29 81       	ldd	r18, Y+1	; 0x01
 31a:	3a 81       	ldd	r19, Y+2	; 0x02
 31c:	2f 5f       	subi	r18, 0xFF	; 255
 31e:	3f 4f       	sbci	r19, 0xFF	; 255
 320:	f9 01       	movw	r30, r18
 322:	20 81       	ld	r18, Z
 324:	fc 01       	movw	r30, r24
 326:	20 83       	st	Z, r18
	while(!(SPSR & (1<<SPIF)));
 328:	00 00       	nop
 32a:	8d e4       	ldi	r24, 0x4D	; 77
 32c:	90 e0       	ldi	r25, 0x00	; 0
 32e:	fc 01       	movw	r30, r24
 330:	80 81       	ld	r24, Z
 332:	88 23       	and	r24, r24
 334:	d4 f7       	brge	.-12     	; 0x32a <write_leds+0x42>
	SPDR = data[2];
 336:	8e e4       	ldi	r24, 0x4E	; 78
 338:	90 e0       	ldi	r25, 0x00	; 0
 33a:	29 81       	ldd	r18, Y+1	; 0x01
 33c:	3a 81       	ldd	r19, Y+2	; 0x02
 33e:	2e 5f       	subi	r18, 0xFE	; 254
 340:	3f 4f       	sbci	r19, 0xFF	; 255
 342:	f9 01       	movw	r30, r18
 344:	20 81       	ld	r18, Z
 346:	fc 01       	movw	r30, r24
 348:	20 83       	st	Z, r18
	while(!(SPSR & (1<<SPIF)));
 34a:	00 00       	nop
 34c:	8d e4       	ldi	r24, 0x4D	; 77
 34e:	90 e0       	ldi	r25, 0x00	; 0
 350:	fc 01       	movw	r30, r24
 352:	80 81       	ld	r24, Z
 354:	88 23       	and	r24, r24
 356:	d4 f7       	brge	.-12     	; 0x34c <write_leds+0x64>
	SPDR = data[3];
 358:	8e e4       	ldi	r24, 0x4E	; 78
 35a:	90 e0       	ldi	r25, 0x00	; 0
 35c:	29 81       	ldd	r18, Y+1	; 0x01
 35e:	3a 81       	ldd	r19, Y+2	; 0x02
 360:	2d 5f       	subi	r18, 0xFD	; 253
 362:	3f 4f       	sbci	r19, 0xFF	; 255
 364:	f9 01       	movw	r30, r18
 366:	20 81       	ld	r18, Z
 368:	fc 01       	movw	r30, r24
 36a:	20 83       	st	Z, r18
	while(!(SPSR & (1<<SPIF)));
 36c:	00 00       	nop
 36e:	8d e4       	ldi	r24, 0x4D	; 77
 370:	90 e0       	ldi	r25, 0x00	; 0
 372:	fc 01       	movw	r30, r24
 374:	80 81       	ld	r24, Z
 376:	88 23       	and	r24, r24
 378:	d4 f7       	brge	.-12     	; 0x36e <write_leds+0x86>

	PORTD |= (1<<PORTD7);
 37a:	8b e2       	ldi	r24, 0x2B	; 43
 37c:	90 e0       	ldi	r25, 0x00	; 0
 37e:	2b e2       	ldi	r18, 0x2B	; 43
 380:	30 e0       	ldi	r19, 0x00	; 0
 382:	f9 01       	movw	r30, r18
 384:	20 81       	ld	r18, Z
 386:	20 68       	ori	r18, 0x80	; 128
 388:	fc 01       	movw	r30, r24
 38a:	20 83       	st	Z, r18
	PORTD &= ~(1<<PORTD7);
 38c:	8b e2       	ldi	r24, 0x2B	; 43
 38e:	90 e0       	ldi	r25, 0x00	; 0
 390:	2b e2       	ldi	r18, 0x2B	; 43
 392:	30 e0       	ldi	r19, 0x00	; 0
 394:	f9 01       	movw	r30, r18
 396:	20 81       	ld	r18, Z
 398:	2f 77       	andi	r18, 0x7F	; 127
 39a:	fc 01       	movw	r30, r24
 39c:	20 83       	st	Z, r18
}
 39e:	0f 90       	pop	r0
 3a0:	0f 90       	pop	r0
 3a2:	cf 91       	pop	r28
 3a4:	df 91       	pop	r29
 3a6:	08 95       	ret

000003a8 <i2c_start>:

void i2c_start()
{
 3a8:	df 93       	push	r29
 3aa:	cf 93       	push	r28
 3ac:	cd b7       	in	r28, 0x3d	; 61
 3ae:	de b7       	in	r29, 0x3e	; 62
	TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN); // send I2C start condition
 3b0:	8c eb       	ldi	r24, 0xBC	; 188
 3b2:	90 e0       	ldi	r25, 0x00	; 0
 3b4:	24 ea       	ldi	r18, 0xA4	; 164
 3b6:	fc 01       	movw	r30, r24
 3b8:	20 83       	st	Z, r18
	while (!(TWCR & (1 << TWINT))); // wait for TWINT flag which says start cond. has been transmitted
 3ba:	00 00       	nop
 3bc:	8c eb       	ldi	r24, 0xBC	; 188
 3be:	90 e0       	ldi	r25, 0x00	; 0
 3c0:	fc 01       	movw	r30, r24
 3c2:	80 81       	ld	r24, Z
 3c4:	88 23       	and	r24, r24
 3c6:	d4 f7       	brge	.-12     	; 0x3bc <i2c_start+0x14>
	if ((TWSR & 0xF8) != 0x08) { // 0x08 = start
 3c8:	89 eb       	ldi	r24, 0xB9	; 185
 3ca:	90 e0       	ldi	r25, 0x00	; 0
 3cc:	fc 01       	movw	r30, r24
 3ce:	80 81       	ld	r24, Z
 3d0:	88 2f       	mov	r24, r24
 3d2:	90 e0       	ldi	r25, 0x00	; 0
 3d4:	88 7f       	andi	r24, 0xF8	; 248
 3d6:	90 70       	andi	r25, 0x00	; 0
 3d8:	88 30       	cpi	r24, 0x08	; 8
 3da:	91 05       	cpc	r25, r1
 3dc:	29 f0       	breq	.+10     	; 0x3e8 <i2c_start+0x40>
		error(TWSR); // return status as error
 3de:	89 eb       	ldi	r24, 0xB9	; 185
 3e0:	90 e0       	ldi	r25, 0x00	; 0
 3e2:	fc 01       	movw	r30, r24
 3e4:	80 81       	ld	r24, Z
 3e6:	69 d1       	rcall	.+722    	; 0x6ba <error>
	}
}
 3e8:	cf 91       	pop	r28
 3ea:	df 91       	pop	r29
 3ec:	08 95       	ret

000003ee <i2c_repeated_start>:

void i2c_repeated_start()
{
 3ee:	df 93       	push	r29
 3f0:	cf 93       	push	r28
 3f2:	cd b7       	in	r28, 0x3d	; 61
 3f4:	de b7       	in	r29, 0x3e	; 62
	TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN); // send I2C start condition
 3f6:	8c eb       	ldi	r24, 0xBC	; 188
 3f8:	90 e0       	ldi	r25, 0x00	; 0
 3fa:	24 ea       	ldi	r18, 0xA4	; 164
 3fc:	fc 01       	movw	r30, r24
 3fe:	20 83       	st	Z, r18
	while (!(TWCR & (1 << TWINT))); // wait for TWINT flag which says start cond. has been transmitted
 400:	00 00       	nop
 402:	8c eb       	ldi	r24, 0xBC	; 188
 404:	90 e0       	ldi	r25, 0x00	; 0
 406:	fc 01       	movw	r30, r24
 408:	80 81       	ld	r24, Z
 40a:	88 23       	and	r24, r24
 40c:	d4 f7       	brge	.-12     	; 0x402 <i2c_repeated_start+0x14>
	if ((TWSR & 0xF8) != 0x10) { // 0x10 = repeated start sent
 40e:	89 eb       	ldi	r24, 0xB9	; 185
 410:	90 e0       	ldi	r25, 0x00	; 0
 412:	fc 01       	movw	r30, r24
 414:	80 81       	ld	r24, Z
 416:	88 2f       	mov	r24, r24
 418:	90 e0       	ldi	r25, 0x00	; 0
 41a:	88 7f       	andi	r24, 0xF8	; 248
 41c:	90 70       	andi	r25, 0x00	; 0
 41e:	80 31       	cpi	r24, 0x10	; 16
 420:	91 05       	cpc	r25, r1
 422:	29 f0       	breq	.+10     	; 0x42e <i2c_repeated_start+0x40>
		error(TWSR); // return status as error
 424:	89 eb       	ldi	r24, 0xB9	; 185
 426:	90 e0       	ldi	r25, 0x00	; 0
 428:	fc 01       	movw	r30, r24
 42a:	80 81       	ld	r24, Z
 42c:	46 d1       	rcall	.+652    	; 0x6ba <error>
	}
}
 42e:	cf 91       	pop	r28
 430:	df 91       	pop	r29
 432:	08 95       	ret

00000434 <i2c_begin_write>:

void i2c_begin_write(uint8_t addr)
{
 434:	df 93       	push	r29
 436:	cf 93       	push	r28
 438:	0f 92       	push	r0
 43a:	cd b7       	in	r28, 0x3d	; 61
 43c:	de b7       	in	r29, 0x3e	; 62
 43e:	89 83       	std	Y+1, r24	; 0x01
	TWDR = addr; // Write to addr
 440:	8b eb       	ldi	r24, 0xBB	; 187
 442:	90 e0       	ldi	r25, 0x00	; 0
 444:	29 81       	ldd	r18, Y+1	; 0x01
 446:	fc 01       	movw	r30, r24
 448:	20 83       	st	Z, r18
	TWCR = (1 << TWINT) | (1 << TWEN); // clear TWINT to start transmission
 44a:	8c eb       	ldi	r24, 0xBC	; 188
 44c:	90 e0       	ldi	r25, 0x00	; 0
 44e:	24 e8       	ldi	r18, 0x84	; 132
 450:	fc 01       	movw	r30, r24
 452:	20 83       	st	Z, r18
	while (!(TWCR & (1 << TWINT))); // wait for TWINT flag which indicates ACK received
 454:	00 00       	nop
 456:	8c eb       	ldi	r24, 0xBC	; 188
 458:	90 e0       	ldi	r25, 0x00	; 0
 45a:	fc 01       	movw	r30, r24
 45c:	80 81       	ld	r24, Z
 45e:	88 23       	and	r24, r24
 460:	d4 f7       	brge	.-12     	; 0x456 <i2c_begin_write+0x22>
	if ((TWSR & 0xF8) != 0x18) { // 0x18 = SLA+W sent, ACK received
 462:	89 eb       	ldi	r24, 0xB9	; 185
 464:	90 e0       	ldi	r25, 0x00	; 0
 466:	fc 01       	movw	r30, r24
 468:	80 81       	ld	r24, Z
 46a:	88 2f       	mov	r24, r24
 46c:	90 e0       	ldi	r25, 0x00	; 0
 46e:	88 7f       	andi	r24, 0xF8	; 248
 470:	90 70       	andi	r25, 0x00	; 0
 472:	88 31       	cpi	r24, 0x18	; 24
 474:	91 05       	cpc	r25, r1
 476:	29 f0       	breq	.+10     	; 0x482 <i2c_begin_write+0x4e>
		error(TWSR); // return status as error
 478:	89 eb       	ldi	r24, 0xB9	; 185
 47a:	90 e0       	ldi	r25, 0x00	; 0
 47c:	fc 01       	movw	r30, r24
 47e:	80 81       	ld	r24, Z
 480:	1c d1       	rcall	.+568    	; 0x6ba <error>
	}
}
 482:	0f 90       	pop	r0
 484:	cf 91       	pop	r28
 486:	df 91       	pop	r29
 488:	08 95       	ret

0000048a <i2c_begin_read>:

void i2c_begin_read(uint8_t addr)
{
 48a:	df 93       	push	r29
 48c:	cf 93       	push	r28
 48e:	0f 92       	push	r0
 490:	cd b7       	in	r28, 0x3d	; 61
 492:	de b7       	in	r29, 0x3e	; 62
 494:	89 83       	std	Y+1, r24	; 0x01
	TWDR = addr | 1; // Read from addr
 496:	8b eb       	ldi	r24, 0xBB	; 187
 498:	90 e0       	ldi	r25, 0x00	; 0
 49a:	29 81       	ldd	r18, Y+1	; 0x01
 49c:	21 60       	ori	r18, 0x01	; 1
 49e:	fc 01       	movw	r30, r24
 4a0:	20 83       	st	Z, r18
	TWCR = (1 << TWINT) | (1 << TWEN); // clear TWINT to start transmission
 4a2:	8c eb       	ldi	r24, 0xBC	; 188
 4a4:	90 e0       	ldi	r25, 0x00	; 0
 4a6:	24 e8       	ldi	r18, 0x84	; 132
 4a8:	fc 01       	movw	r30, r24
 4aa:	20 83       	st	Z, r18
	while (!(TWCR & (1 << TWINT))); // wait for TWINT flag which indicates ACK received
 4ac:	00 00       	nop
 4ae:	8c eb       	ldi	r24, 0xBC	; 188
 4b0:	90 e0       	ldi	r25, 0x00	; 0
 4b2:	fc 01       	movw	r30, r24
 4b4:	80 81       	ld	r24, Z
 4b6:	88 23       	and	r24, r24
 4b8:	d4 f7       	brge	.-12     	; 0x4ae <i2c_begin_read+0x24>
	if ((TWSR & 0xF8) != 0x40) { // 0x40 = SLA+R sent, ACK received
 4ba:	89 eb       	ldi	r24, 0xB9	; 185
 4bc:	90 e0       	ldi	r25, 0x00	; 0
 4be:	fc 01       	movw	r30, r24
 4c0:	80 81       	ld	r24, Z
 4c2:	88 2f       	mov	r24, r24
 4c4:	90 e0       	ldi	r25, 0x00	; 0
 4c6:	88 7f       	andi	r24, 0xF8	; 248
 4c8:	90 70       	andi	r25, 0x00	; 0
 4ca:	80 34       	cpi	r24, 0x40	; 64
 4cc:	91 05       	cpc	r25, r1
 4ce:	29 f0       	breq	.+10     	; 0x4da <i2c_begin_read+0x50>
		error(TWSR); // return status as error
 4d0:	89 eb       	ldi	r24, 0xB9	; 185
 4d2:	90 e0       	ldi	r25, 0x00	; 0
 4d4:	fc 01       	movw	r30, r24
 4d6:	80 81       	ld	r24, Z
 4d8:	f0 d0       	rcall	.+480    	; 0x6ba <error>
	}
}
 4da:	0f 90       	pop	r0
 4dc:	cf 91       	pop	r28
 4de:	df 91       	pop	r29
 4e0:	08 95       	ret

000004e2 <i2c_write>:

void i2c_write(uint8_t data)
{
 4e2:	df 93       	push	r29
 4e4:	cf 93       	push	r28
 4e6:	0f 92       	push	r0
 4e8:	cd b7       	in	r28, 0x3d	; 61
 4ea:	de b7       	in	r29, 0x3e	; 62
 4ec:	89 83       	std	Y+1, r24	; 0x01
	TWDR = data; // Output data
 4ee:	8b eb       	ldi	r24, 0xBB	; 187
 4f0:	90 e0       	ldi	r25, 0x00	; 0
 4f2:	29 81       	ldd	r18, Y+1	; 0x01
 4f4:	fc 01       	movw	r30, r24
 4f6:	20 83       	st	Z, r18
	TWCR = (1 << TWINT) | (1 << TWEN); // clear TWINT to start transmission
 4f8:	8c eb       	ldi	r24, 0xBC	; 188
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	24 e8       	ldi	r18, 0x84	; 132
 4fe:	fc 01       	movw	r30, r24
 500:	20 83       	st	Z, r18
	while (!(TWCR & (1 << TWINT))); // wait for TWINT flag which indicates ACK received
 502:	00 00       	nop
 504:	8c eb       	ldi	r24, 0xBC	; 188
 506:	90 e0       	ldi	r25, 0x00	; 0
 508:	fc 01       	movw	r30, r24
 50a:	80 81       	ld	r24, Z
 50c:	88 23       	and	r24, r24
 50e:	d4 f7       	brge	.-12     	; 0x504 <i2c_write+0x22>
	if ((TWSR & 0xF8) != 0x28) { // 0x28 = Data byte sent, ACK received
 510:	89 eb       	ldi	r24, 0xB9	; 185
 512:	90 e0       	ldi	r25, 0x00	; 0
 514:	fc 01       	movw	r30, r24
 516:	80 81       	ld	r24, Z
 518:	88 2f       	mov	r24, r24
 51a:	90 e0       	ldi	r25, 0x00	; 0
 51c:	88 7f       	andi	r24, 0xF8	; 248
 51e:	90 70       	andi	r25, 0x00	; 0
 520:	88 32       	cpi	r24, 0x28	; 40
 522:	91 05       	cpc	r25, r1
 524:	29 f0       	breq	.+10     	; 0x530 <i2c_write+0x4e>
		error(TWSR); // return status as error
 526:	89 eb       	ldi	r24, 0xB9	; 185
 528:	90 e0       	ldi	r25, 0x00	; 0
 52a:	fc 01       	movw	r30, r24
 52c:	80 81       	ld	r24, Z
 52e:	c5 d0       	rcall	.+394    	; 0x6ba <error>
	}
}
 530:	0f 90       	pop	r0
 532:	cf 91       	pop	r28
 534:	df 91       	pop	r29
 536:	08 95       	ret

00000538 <i2c_read_ack>:

void i2c_read_ack(uint8_t* data)
{
 538:	df 93       	push	r29
 53a:	cf 93       	push	r28
 53c:	00 d0       	rcall	.+0      	; 0x53e <i2c_read_ack+0x6>
 53e:	cd b7       	in	r28, 0x3d	; 61
 540:	de b7       	in	r29, 0x3e	; 62
 542:	9a 83       	std	Y+2, r25	; 0x02
 544:	89 83       	std	Y+1, r24	; 0x01
	TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA); // clear TWINT to start transmission
 546:	8c eb       	ldi	r24, 0xBC	; 188
 548:	90 e0       	ldi	r25, 0x00	; 0
 54a:	24 ec       	ldi	r18, 0xC4	; 196
 54c:	fc 01       	movw	r30, r24
 54e:	20 83       	st	Z, r18
	while (!(TWCR & (1 << TWINT))); // wait for TWINT flag which indicates byte received
 550:	00 00       	nop
 552:	8c eb       	ldi	r24, 0xBC	; 188
 554:	90 e0       	ldi	r25, 0x00	; 0
 556:	fc 01       	movw	r30, r24
 558:	80 81       	ld	r24, Z
 55a:	88 23       	and	r24, r24
 55c:	d4 f7       	brge	.-12     	; 0x552 <i2c_read_ack+0x1a>
	if ((TWSR & 0xF8) != 0x50) { // 0x50 = Data byte sent, ACK received
 55e:	89 eb       	ldi	r24, 0xB9	; 185
 560:	90 e0       	ldi	r25, 0x00	; 0
 562:	fc 01       	movw	r30, r24
 564:	80 81       	ld	r24, Z
 566:	88 2f       	mov	r24, r24
 568:	90 e0       	ldi	r25, 0x00	; 0
 56a:	88 7f       	andi	r24, 0xF8	; 248
 56c:	90 70       	andi	r25, 0x00	; 0
 56e:	80 35       	cpi	r24, 0x50	; 80
 570:	91 05       	cpc	r25, r1
 572:	29 f0       	breq	.+10     	; 0x57e <i2c_read_ack+0x46>
		error(TWSR); // return status as error
 574:	89 eb       	ldi	r24, 0xB9	; 185
 576:	90 e0       	ldi	r25, 0x00	; 0
 578:	fc 01       	movw	r30, r24
 57a:	80 81       	ld	r24, Z
 57c:	9e d0       	rcall	.+316    	; 0x6ba <error>
	}
	*data=TWDR;
 57e:	8b eb       	ldi	r24, 0xBB	; 187
 580:	90 e0       	ldi	r25, 0x00	; 0
 582:	fc 01       	movw	r30, r24
 584:	20 81       	ld	r18, Z
 586:	89 81       	ldd	r24, Y+1	; 0x01
 588:	9a 81       	ldd	r25, Y+2	; 0x02
 58a:	fc 01       	movw	r30, r24
 58c:	20 83       	st	Z, r18
}
 58e:	0f 90       	pop	r0
 590:	0f 90       	pop	r0
 592:	cf 91       	pop	r28
 594:	df 91       	pop	r29
 596:	08 95       	ret

00000598 <i2c_read_nack>:

void i2c_read_nack(uint8_t* data)
{
 598:	df 93       	push	r29
 59a:	cf 93       	push	r28
 59c:	00 d0       	rcall	.+0      	; 0x59e <i2c_read_nack+0x6>
 59e:	cd b7       	in	r28, 0x3d	; 61
 5a0:	de b7       	in	r29, 0x3e	; 62
 5a2:	9a 83       	std	Y+2, r25	; 0x02
 5a4:	89 83       	std	Y+1, r24	; 0x01
	TWCR = (1 << TWINT) | (1 << TWEN); // clear TWINT to start transmission
 5a6:	8c eb       	ldi	r24, 0xBC	; 188
 5a8:	90 e0       	ldi	r25, 0x00	; 0
 5aa:	24 e8       	ldi	r18, 0x84	; 132
 5ac:	fc 01       	movw	r30, r24
 5ae:	20 83       	st	Z, r18
	while (!(TWCR & (1 << TWINT))); // wait for TWINT flag which indicates byte received
 5b0:	00 00       	nop
 5b2:	8c eb       	ldi	r24, 0xBC	; 188
 5b4:	90 e0       	ldi	r25, 0x00	; 0
 5b6:	fc 01       	movw	r30, r24
 5b8:	80 81       	ld	r24, Z
 5ba:	88 23       	and	r24, r24
 5bc:	d4 f7       	brge	.-12     	; 0x5b2 <i2c_read_nack+0x1a>
	if ((TWSR & 0xF8) != 0x58) { // 0x58 = Data byte sent, NACK received
 5be:	89 eb       	ldi	r24, 0xB9	; 185
 5c0:	90 e0       	ldi	r25, 0x00	; 0
 5c2:	fc 01       	movw	r30, r24
 5c4:	80 81       	ld	r24, Z
 5c6:	88 2f       	mov	r24, r24
 5c8:	90 e0       	ldi	r25, 0x00	; 0
 5ca:	88 7f       	andi	r24, 0xF8	; 248
 5cc:	90 70       	andi	r25, 0x00	; 0
 5ce:	88 35       	cpi	r24, 0x58	; 88
 5d0:	91 05       	cpc	r25, r1
 5d2:	29 f0       	breq	.+10     	; 0x5de <i2c_read_nack+0x46>
		error(TWSR); // return status as error
 5d4:	89 eb       	ldi	r24, 0xB9	; 185
 5d6:	90 e0       	ldi	r25, 0x00	; 0
 5d8:	fc 01       	movw	r30, r24
 5da:	80 81       	ld	r24, Z
 5dc:	6e d0       	rcall	.+220    	; 0x6ba <error>
	}
	*data=TWDR;
 5de:	8b eb       	ldi	r24, 0xBB	; 187
 5e0:	90 e0       	ldi	r25, 0x00	; 0
 5e2:	fc 01       	movw	r30, r24
 5e4:	20 81       	ld	r18, Z
 5e6:	89 81       	ldd	r24, Y+1	; 0x01
 5e8:	9a 81       	ldd	r25, Y+2	; 0x02
 5ea:	fc 01       	movw	r30, r24
 5ec:	20 83       	st	Z, r18
}
 5ee:	0f 90       	pop	r0
 5f0:	0f 90       	pop	r0
 5f2:	cf 91       	pop	r28
 5f4:	df 91       	pop	r29
 5f6:	08 95       	ret

000005f8 <i2c_stop>:

void i2c_stop()
{
 5f8:	df 93       	push	r29
 5fa:	cf 93       	push	r28
 5fc:	cd b7       	in	r28, 0x3d	; 61
 5fe:	de b7       	in	r29, 0x3e	; 62
	TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN); // send I2C stop condition
 600:	8c eb       	ldi	r24, 0xBC	; 188
 602:	90 e0       	ldi	r25, 0x00	; 0
 604:	24 e9       	ldi	r18, 0x94	; 148
 606:	fc 01       	movw	r30, r24
 608:	20 83       	st	Z, r18
}
 60a:	cf 91       	pop	r28
 60c:	df 91       	pop	r29
 60e:	08 95       	ret

00000610 <accel_read_single>:

// Read a single byte from a register in the accelerometer
void accel_read_single(uint8_t addr,uint8_t reg,uint8_t* datum)
{
 610:	df 93       	push	r29
 612:	cf 93       	push	r28
 614:	00 d0       	rcall	.+0      	; 0x616 <accel_read_single+0x6>
 616:	00 d0       	rcall	.+0      	; 0x618 <accel_read_single+0x8>
 618:	cd b7       	in	r28, 0x3d	; 61
 61a:	de b7       	in	r29, 0x3e	; 62
 61c:	89 83       	std	Y+1, r24	; 0x01
 61e:	6a 83       	std	Y+2, r22	; 0x02
 620:	5c 83       	std	Y+4, r21	; 0x04
 622:	4b 83       	std	Y+3, r20	; 0x03
	i2c_start();
 624:	c1 de       	rcall	.-638    	; 0x3a8 <i2c_start>
	i2c_begin_write(addr);
 626:	89 81       	ldd	r24, Y+1	; 0x01
 628:	05 df       	rcall	.-502    	; 0x434 <i2c_begin_write>
	i2c_write(reg);
 62a:	8a 81       	ldd	r24, Y+2	; 0x02
 62c:	5a df       	rcall	.-332    	; 0x4e2 <i2c_write>
	i2c_repeated_start();
 62e:	df de       	rcall	.-578    	; 0x3ee <i2c_repeated_start>
	i2c_begin_read(addr);
 630:	89 81       	ldd	r24, Y+1	; 0x01
 632:	2b df       	rcall	.-426    	; 0x48a <i2c_begin_read>
	i2c_read_nack(datum);
 634:	8b 81       	ldd	r24, Y+3	; 0x03
 636:	9c 81       	ldd	r25, Y+4	; 0x04
 638:	af df       	rcall	.-162    	; 0x598 <i2c_read_nack>
	i2c_stop();
 63a:	de df       	rcall	.-68     	; 0x5f8 <i2c_stop>
}
 63c:	0f 90       	pop	r0
 63e:	0f 90       	pop	r0
 640:	0f 90       	pop	r0
 642:	0f 90       	pop	r0
 644:	cf 91       	pop	r28
 646:	df 91       	pop	r29
 648:	08 95       	ret

0000064a <accel_read_double>:

// Read two bytes from a register pair in the accelerometer
void accel_read_double(uint8_t addr,uint8_t reg,uint8_t* datum)
{
 64a:	df 93       	push	r29
 64c:	cf 93       	push	r28
 64e:	00 d0       	rcall	.+0      	; 0x650 <accel_read_double+0x6>
 650:	00 d0       	rcall	.+0      	; 0x652 <accel_read_double+0x8>
 652:	cd b7       	in	r28, 0x3d	; 61
 654:	de b7       	in	r29, 0x3e	; 62
 656:	89 83       	std	Y+1, r24	; 0x01
 658:	6a 83       	std	Y+2, r22	; 0x02
 65a:	5c 83       	std	Y+4, r21	; 0x04
 65c:	4b 83       	std	Y+3, r20	; 0x03
	i2c_start();
 65e:	a4 de       	rcall	.-696    	; 0x3a8 <i2c_start>
	i2c_begin_write(addr);
 660:	89 81       	ldd	r24, Y+1	; 0x01
 662:	e8 de       	rcall	.-560    	; 0x434 <i2c_begin_write>
	i2c_write(reg);
 664:	8a 81       	ldd	r24, Y+2	; 0x02
 666:	3d df       	rcall	.-390    	; 0x4e2 <i2c_write>
	i2c_repeated_start();
 668:	c2 de       	rcall	.-636    	; 0x3ee <i2c_repeated_start>
	i2c_begin_read(addr);
 66a:	89 81       	ldd	r24, Y+1	; 0x01
 66c:	0e df       	rcall	.-484    	; 0x48a <i2c_begin_read>
	i2c_read_ack(&datum[1]);
 66e:	8b 81       	ldd	r24, Y+3	; 0x03
 670:	9c 81       	ldd	r25, Y+4	; 0x04
 672:	01 96       	adiw	r24, 0x01	; 1
 674:	61 df       	rcall	.-318    	; 0x538 <i2c_read_ack>
	i2c_read_nack(&datum[0]);
 676:	8b 81       	ldd	r24, Y+3	; 0x03
 678:	9c 81       	ldd	r25, Y+4	; 0x04
 67a:	8e df       	rcall	.-228    	; 0x598 <i2c_read_nack>
	i2c_stop();
 67c:	bd df       	rcall	.-134    	; 0x5f8 <i2c_stop>
}
 67e:	0f 90       	pop	r0
 680:	0f 90       	pop	r0
 682:	0f 90       	pop	r0
 684:	0f 90       	pop	r0
 686:	cf 91       	pop	r28
 688:	df 91       	pop	r29
 68a:	08 95       	ret

0000068c <accel_write_single>:

// Write a single byte to a register in the accelerometer
void accel_write_single(uint8_t addr,uint8_t reg,uint8_t datum)
{
 68c:	df 93       	push	r29
 68e:	cf 93       	push	r28
 690:	00 d0       	rcall	.+0      	; 0x692 <accel_write_single+0x6>
 692:	0f 92       	push	r0
 694:	cd b7       	in	r28, 0x3d	; 61
 696:	de b7       	in	r29, 0x3e	; 62
 698:	89 83       	std	Y+1, r24	; 0x01
 69a:	6a 83       	std	Y+2, r22	; 0x02
 69c:	4b 83       	std	Y+3, r20	; 0x03
	i2c_start();
 69e:	84 de       	rcall	.-760    	; 0x3a8 <i2c_start>
	i2c_begin_write(addr);
 6a0:	89 81       	ldd	r24, Y+1	; 0x01
 6a2:	c8 de       	rcall	.-624    	; 0x434 <i2c_begin_write>
	i2c_write(reg);
 6a4:	8a 81       	ldd	r24, Y+2	; 0x02
 6a6:	1d df       	rcall	.-454    	; 0x4e2 <i2c_write>
	i2c_write(datum);
 6a8:	8b 81       	ldd	r24, Y+3	; 0x03
 6aa:	1b df       	rcall	.-458    	; 0x4e2 <i2c_write>
	i2c_stop();
 6ac:	a5 df       	rcall	.-182    	; 0x5f8 <i2c_stop>
}
 6ae:	0f 90       	pop	r0
 6b0:	0f 90       	pop	r0
 6b2:	0f 90       	pop	r0
 6b4:	cf 91       	pop	r28
 6b6:	df 91       	pop	r29
 6b8:	08 95       	ret

000006ba <error>:

// Turn on red LEDs and wait forever
void error(uint8_t code)
{
 6ba:	df 93       	push	r29
 6bc:	cf 93       	push	r28
 6be:	00 d0       	rcall	.+0      	; 0x6c0 <error+0x6>
 6c0:	00 d0       	rcall	.+0      	; 0x6c2 <error+0x8>
 6c2:	0f 92       	push	r0
 6c4:	cd b7       	in	r28, 0x3d	; 61
 6c6:	de b7       	in	r29, 0x3e	; 62
 6c8:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t frame[4];
	frame[0]=0;
 6ca:	19 82       	std	Y+1, r1	; 0x01
	frame[1]=code;
 6cc:	8d 81       	ldd	r24, Y+5	; 0x05
 6ce:	8a 83       	std	Y+2, r24	; 0x02
	frame[2]=0;
 6d0:	1b 82       	std	Y+3, r1	; 0x03
	frame[3]=code;
 6d2:	8d 81       	ldd	r24, Y+5	; 0x05
 6d4:	8c 83       	std	Y+4, r24	; 0x04
	write_leds(frame);
 6d6:	ce 01       	movw	r24, r28
 6d8:	01 96       	adiw	r24, 0x01	; 1
 6da:	06 de       	rcall	.-1012   	; 0x2e8 <write_leds>
	for(;;);
 6dc:	ff cf       	rjmp	.-2      	; 0x6dc <error+0x22>

000006de <print>:
}

// Turn on green LEDs
void print(uint8_t code)
{
 6de:	df 93       	push	r29
 6e0:	cf 93       	push	r28
 6e2:	00 d0       	rcall	.+0      	; 0x6e4 <print+0x6>
 6e4:	00 d0       	rcall	.+0      	; 0x6e6 <print+0x8>
 6e6:	0f 92       	push	r0
 6e8:	cd b7       	in	r28, 0x3d	; 61
 6ea:	de b7       	in	r29, 0x3e	; 62
 6ec:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t frame[4];
	frame[0]=code;
 6ee:	8d 81       	ldd	r24, Y+5	; 0x05
 6f0:	89 83       	std	Y+1, r24	; 0x01
	frame[1]=0;
 6f2:	1a 82       	std	Y+2, r1	; 0x02
	frame[2]=code;
 6f4:	8d 81       	ldd	r24, Y+5	; 0x05
 6f6:	8b 83       	std	Y+3, r24	; 0x03
	frame[3]=0;
 6f8:	1c 82       	std	Y+4, r1	; 0x04
	write_leds(frame);
 6fa:	ce 01       	movw	r24, r28
 6fc:	01 96       	adiw	r24, 0x01	; 1
 6fe:	f4 dd       	rcall	.-1048   	; 0x2e8 <write_leds>
}
 700:	0f 90       	pop	r0
 702:	0f 90       	pop	r0
 704:	0f 90       	pop	r0
 706:	0f 90       	pop	r0
 708:	0f 90       	pop	r0
 70a:	cf 91       	pop	r28
 70c:	df 91       	pop	r29
 70e:	08 95       	ret

00000710 <power_on_periph>:

void power_on_periph()
{
 710:	df 93       	push	r29
 712:	cf 93       	push	r28
 714:	cd b7       	in	r28, 0x3d	; 61
 716:	de b7       	in	r29, 0x3e	; 62
	PORTB &= ~(1<<PB2); // Turn power on to everything
 718:	85 e2       	ldi	r24, 0x25	; 37
 71a:	90 e0       	ldi	r25, 0x00	; 0
 71c:	25 e2       	ldi	r18, 0x25	; 37
 71e:	30 e0       	ldi	r19, 0x00	; 0
 720:	f9 01       	movw	r30, r18
 722:	20 81       	ld	r18, Z
 724:	2b 7f       	andi	r18, 0xFB	; 251
 726:	fc 01       	movw	r30, r24
 728:	20 83       	st	Z, r18
}
 72a:	cf 91       	pop	r28
 72c:	df 91       	pop	r29
 72e:	08 95       	ret

00000730 <power_off_periph>:

void power_off_periph()
{
 730:	df 93       	push	r29
 732:	cf 93       	push	r28
 734:	cd b7       	in	r28, 0x3d	; 61
 736:	de b7       	in	r29, 0x3e	; 62
	PORTB |= (1<<PB2); // Turn power off to everything
 738:	85 e2       	ldi	r24, 0x25	; 37
 73a:	90 e0       	ldi	r25, 0x00	; 0
 73c:	25 e2       	ldi	r18, 0x25	; 37
 73e:	30 e0       	ldi	r19, 0x00	; 0
 740:	f9 01       	movw	r30, r18
 742:	20 81       	ld	r18, Z
 744:	24 60       	ori	r18, 0x04	; 4
 746:	fc 01       	movw	r30, r24
 748:	20 83       	st	Z, r18
}
 74a:	cf 91       	pop	r28
 74c:	df 91       	pop	r29
 74e:	08 95       	ret

00000750 <uc_sleep>:

void uc_sleep()
{
 750:	df 93       	push	r29
 752:	cf 93       	push	r28
 754:	cd b7       	in	r28, 0x3d	; 61
 756:	de b7       	in	r29, 0x3e	; 62
	SMCR |= (1<<SM1) | (1<<SE); // Sleep mode is power-down, sleep enable
 758:	83 e5       	ldi	r24, 0x53	; 83
 75a:	90 e0       	ldi	r25, 0x00	; 0
 75c:	23 e5       	ldi	r18, 0x53	; 83
 75e:	30 e0       	ldi	r19, 0x00	; 0
 760:	f9 01       	movw	r30, r18
 762:	20 81       	ld	r18, Z
 764:	25 60       	ori	r18, 0x05	; 5
 766:	fc 01       	movw	r30, r24
 768:	20 83       	st	Z, r18
	sleep_cpu();
 76a:	88 95       	sleep
	while(PIND & (1<<PIND2)); // TODO: replace busy-wait with interrupt enable + WFI sleep
 76c:	00 00       	nop
 76e:	89 e2       	ldi	r24, 0x29	; 41
 770:	90 e0       	ldi	r25, 0x00	; 0
 772:	fc 01       	movw	r30, r24
 774:	80 81       	ld	r24, Z
 776:	88 2f       	mov	r24, r24
 778:	90 e0       	ldi	r25, 0x00	; 0
 77a:	84 70       	andi	r24, 0x04	; 4
 77c:	90 70       	andi	r25, 0x00	; 0
 77e:	00 97       	sbiw	r24, 0x00	; 0
 780:	b1 f7       	brne	.-20     	; 0x76e <uc_sleep+0x1e>
	sei();
	sleep_cpu();
	cli();
	SMCR &= ~(1<<SE);
	*/
}
 782:	cf 91       	pop	r28
 784:	df 91       	pop	r29
 786:	08 95       	ret

00000788 <main>:
#include "power.h"

void pause();

int main()
{
 788:	df 93       	push	r29
 78a:	cf 93       	push	r28
 78c:	cd b7       	in	r28, 0x3d	; 61
 78e:	de b7       	in	r29, 0x3e	; 62
 790:	66 97       	sbiw	r28, 0x16	; 22
 792:	0f b6       	in	r0, 0x3f	; 63
 794:	f8 94       	cli
 796:	de bf       	out	0x3e, r29	; 62
 798:	0f be       	out	0x3f, r0	; 63
 79a:	cd bf       	out	0x3d, r28	; 61
	int16_t result;
	uint8_t display;

	uint8_t pattern[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x40,0x20,0x10,0x08,0x04,0x02};
 79c:	ce 01       	movw	r24, r28
 79e:	05 96       	adiw	r24, 0x05	; 5
 7a0:	20 e0       	ldi	r18, 0x00	; 0
 7a2:	31 e0       	ldi	r19, 0x01	; 1
 7a4:	4e e0       	ldi	r20, 0x0E	; 14
 7a6:	f9 01       	movw	r30, r18
 7a8:	00 80       	ld	r0, Z
 7aa:	2f 5f       	subi	r18, 0xFF	; 255
 7ac:	3f 4f       	sbci	r19, 0xFF	; 255
 7ae:	fc 01       	movw	r30, r24
 7b0:	00 82       	st	Z, r0
 7b2:	01 96       	adiw	r24, 0x01	; 1
 7b4:	41 50       	subi	r20, 0x01	; 1
 7b6:	44 23       	and	r20, r20
 7b8:	b1 f7       	brne	.-20     	; 0x7a6 <main+0x1e>
	//uint8_t pattern[] = {0x42,0x86,0x8a,0x92,0x62,0x00,0x02,0x00,0x7c,0x82,0x82,0x82,0x7c,0x00,0x7c,0x82,0x82,0x82,0x7c,0x00,0x6c,0x92,0x92,0x92,0x6c,0x00,0x00,0x00,0x00};
	uint8_t pat_len = 14;
 7ba:	8e e0       	ldi	r24, 0x0E	; 14
 7bc:	8a 83       	std	Y+2, r24	; 0x02
	//uint8_t pat_len = 30;
	uint8_t i=pat_len;
 7be:	8a 81       	ldd	r24, Y+2	; 0x02
 7c0:	89 83       	std	Y+1, r24	; 0x01
	uint8_t frame[4];

	uint16_t j;
	int16_t ca;

	init();
 7c2:	40 dd       	rcall	.-1408   	; 0x244 <init>
	accel_init();
 7c4:	4d dc       	rcall	.-1894   	; 0x60 <accel_init>
 7c6:	01 c0       	rjmp	.+2      	; 0x7ca <main+0x42>
				i=pat_len;
			}
			write_leds(frame);
			i--;
		}
	}
 7c8:	00 00       	nop
	init();
	accel_init();

	for(;;)
	{
		sleep();
 7ca:	58 d0       	rcall	.+176    	; 0x87c <sleep>
		for(;;)
		{
			frame[0]=pattern[i];
 7cc:	89 81       	ldd	r24, Y+1	; 0x01
 7ce:	88 2f       	mov	r24, r24
 7d0:	90 e0       	ldi	r25, 0x00	; 0
 7d2:	9e 01       	movw	r18, r28
 7d4:	2b 5f       	subi	r18, 0xFB	; 251
 7d6:	3f 4f       	sbci	r19, 0xFF	; 255
 7d8:	82 0f       	add	r24, r18
 7da:	93 1f       	adc	r25, r19
 7dc:	fc 01       	movw	r30, r24
 7de:	80 81       	ld	r24, Z
 7e0:	8b 8b       	std	Y+19, r24	; 0x13
			frame[2]=pattern[i];
 7e2:	89 81       	ldd	r24, Y+1	; 0x01
 7e4:	88 2f       	mov	r24, r24
 7e6:	90 e0       	ldi	r25, 0x00	; 0
 7e8:	9e 01       	movw	r18, r28
 7ea:	2b 5f       	subi	r18, 0xFB	; 251
 7ec:	3f 4f       	sbci	r19, 0xFF	; 255
 7ee:	82 0f       	add	r24, r18
 7f0:	93 1f       	adc	r25, r19
 7f2:	fc 01       	movw	r30, r24
 7f4:	80 81       	ld	r24, Z
 7f6:	8d 8b       	std	Y+21, r24	; 0x15
			frame[1]=pattern[i];
 7f8:	89 81       	ldd	r24, Y+1	; 0x01
 7fa:	88 2f       	mov	r24, r24
 7fc:	90 e0       	ldi	r25, 0x00	; 0
 7fe:	9e 01       	movw	r18, r28
 800:	2b 5f       	subi	r18, 0xFB	; 251
 802:	3f 4f       	sbci	r19, 0xFF	; 255
 804:	82 0f       	add	r24, r18
 806:	93 1f       	adc	r25, r19
 808:	fc 01       	movw	r30, r24
 80a:	80 81       	ld	r24, Z
 80c:	8c 8b       	std	Y+20, r24	; 0x14
			frame[3]=pattern[i];
 80e:	89 81       	ldd	r24, Y+1	; 0x01
 810:	88 2f       	mov	r24, r24
 812:	90 e0       	ldi	r25, 0x00	; 0
 814:	9e 01       	movw	r18, r28
 816:	2b 5f       	subi	r18, 0xFB	; 251
 818:	3f 4f       	sbci	r19, 0xFF	; 255
 81a:	82 0f       	add	r24, r18
 81c:	93 1f       	adc	r25, r19
 81e:	fc 01       	movw	r30, r24
 820:	80 81       	ld	r24, Z
 822:	8e 8b       	std	Y+22, r24	; 0x16

			if(i==0)
 824:	89 81       	ldd	r24, Y+1	; 0x01
 826:	88 23       	and	r24, r24
 828:	51 f4       	brne	.+20     	; 0x83e <main+0xb6>
			{
				ca=get_centrifugal_acceleration();
 82a:	d2 dc       	rcall	.-1628   	; 0x1d0 <get_centrifugal_acceleration>
 82c:	9c 83       	std	Y+4, r25	; 0x04
 82e:	8b 83       	std	Y+3, r24	; 0x03
				if(ca<50)
 830:	8b 81       	ldd	r24, Y+3	; 0x03
 832:	9c 81       	ldd	r25, Y+4	; 0x04
 834:	82 33       	cpi	r24, 0x32	; 50
 836:	91 05       	cpc	r25, r1
 838:	3c f2       	brlt	.-114    	; 0x7c8 <main+0x40>
				{
					break;
				}
				i=pat_len;
 83a:	8a 81       	ldd	r24, Y+2	; 0x02
 83c:	89 83       	std	Y+1, r24	; 0x01
			}
			write_leds(frame);
 83e:	ce 01       	movw	r24, r28
 840:	43 96       	adiw	r24, 0x13	; 19
 842:	52 dd       	rcall	.-1372   	; 0x2e8 <write_leds>
			i--;
 844:	89 81       	ldd	r24, Y+1	; 0x01
 846:	81 50       	subi	r24, 0x01	; 1
 848:	89 83       	std	Y+1, r24	; 0x01
		}
 84a:	c0 cf       	rjmp	.-128    	; 0x7cc <main+0x44>

0000084c <pause>:

	return 0;
}

void pause()
{
 84c:	df 93       	push	r29
 84e:	cf 93       	push	r28
 850:	00 d0       	rcall	.+0      	; 0x852 <pause+0x6>
 852:	cd b7       	in	r28, 0x3d	; 61
 854:	de b7       	in	r29, 0x3e	; 62
	uint16_t i;
	for(i=0;i<1000;i++)
 856:	1a 82       	std	Y+2, r1	; 0x02
 858:	19 82       	std	Y+1, r1	; 0x01
 85a:	05 c0       	rjmp	.+10     	; 0x866 <pause+0x1a>
 85c:	89 81       	ldd	r24, Y+1	; 0x01
 85e:	9a 81       	ldd	r25, Y+2	; 0x02
 860:	01 96       	adiw	r24, 0x01	; 1
 862:	9a 83       	std	Y+2, r25	; 0x02
 864:	89 83       	std	Y+1, r24	; 0x01
 866:	89 81       	ldd	r24, Y+1	; 0x01
 868:	9a 81       	ldd	r25, Y+2	; 0x02
 86a:	23 e0       	ldi	r18, 0x03	; 3
 86c:	88 3e       	cpi	r24, 0xE8	; 232
 86e:	92 07       	cpc	r25, r18
 870:	a8 f3       	brcs	.-22     	; 0x85c <pause+0x10>
	{
	}
}
 872:	0f 90       	pop	r0
 874:	0f 90       	pop	r0
 876:	cf 91       	pop	r28
 878:	df 91       	pop	r29
 87a:	08 95       	ret

0000087c <sleep>:
#include "accel.h"
#include "hal.h"


void sleep()
{
 87c:	df 93       	push	r29
 87e:	cf 93       	push	r28
 880:	cd b7       	in	r28, 0x3d	; 61
 882:	de b7       	in	r29, 0x3e	; 62
	accel_sleep(); // Doing this before power_off is oddly important
 884:	87 dc       	rcall	.-1778   	; 0x194 <accel_sleep>
	power_off_periph();
 886:	54 df       	rcall	.-344    	; 0x730 <power_off_periph>
	uc_sleep();
 888:	63 df       	rcall	.-314    	; 0x750 <uc_sleep>
	power_on_periph();
 88a:	42 df       	rcall	.-380    	; 0x710 <power_on_periph>
	accel_run();
 88c:	59 dc       	rcall	.-1870   	; 0x140 <accel_run>
}
 88e:	cf 91       	pop	r28
 890:	df 91       	pop	r29
 892:	08 95       	ret

00000894 <_exit>:
 894:	f8 94       	cli

00000896 <__stop_program>:
 896:	ff cf       	rjmp	.-2      	; 0x896 <__stop_program>
